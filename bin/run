#!/usr/bin/env ruby

require 'action_cable_client'
require 'optparse'

DEFAULTS = {
  gpio_util_path: '/home/mackinley/pi-actioncable-testing/bin/gpio_util',
  action_cable_host: 'localhost',
  action_cable_port: '3000'
}
parsed_options = DEFAULTS.dup
OptionParser.new do |opts|
  opts.on('-g', '--gpioutil-path=port', 'Path to gpio_util') do |v|
    parsed_options[:gpio_util_path] = v
  end
  opts.on('-h', '--actioncable-host=host', 'ActionCable Host') do |v|
    parsed_options[:action_cable_host] = v
  end
  opts.on('-p', '--actioncable-port=port', 'ActionCable Port') do |v|
    parsed_options[:action_cable_port] = v
  end
end.parse!

uri = "ws://#{parsed_options[:action_cable_host]}:#{parsed_options[:action_cable_port]}/cable"

EventMachine.run do
  outputs_channel = ActionCableClient.new(uri, 'GpioOutputsChannel')

  outputs_channel.connected { puts 'Outputs connected!' }

  outputs_channel.subscribed do
    outputs_channel.perform('follow', {})
  end

  # called whenever a message is received from the server
  outputs_channel.received do |msg|
    puts "Output received: #{msg}"
    gpio_output = msg['message']['gpio_output']
    Thread.new do
      system "sudo #{parsed_options[:gpio_util_path]} -p #{gpio_output['pin']} #{gpio_output['value']}"
    end
  end

  outputs_channel.disconnected { puts 'Outputs disconnected!' }

  outputs_channel.errored {|msg| puts msg }

  inputs_channel = ActionCableClient.new(uri, 'GpioInputsChannel')

  inputs_channel.connected { puts 'Inputs connected!' }

  inputs_channel.subscribed do
    inputs_channel.perform('follow', {})
  end

  # called whenever a message is received from the server
  inputs_channel.received do |msg|
    puts "Input received: #{msg}"
    gpio_input = msg['message']['gpio_input']
    Thread.new do
      case gpio_input['mode']
        when 'read'
          system("#{parsed_options[:gpio_util_path]} -p #{gpio_input['pin']} -d in -m down")
        when 'wait_for_up'
          system("#{parsed_options[:gpio_util_path]} -p #{gpio_input['pin']} -d in -m down -a wait_for_up")
          puts "#{gpio_input['pin']} went up!"
          inputs_channel.perform('create', {pin: 23, mode: 'wait_for_down'})
          outputs_channel.perform('create', {pin: 17, value: 1})
        when 'wait_for_down'
          system("#{parsed_options[:gpio_util_path]} -p #{gpio_input['pin']} -d in -m down -a wait_for_down")
          puts "#{gpio_input['pin']} went down!"
          outputs_channel.perform('create', {pin: 17, value: 0})
      end
    end
  end

  inputs_channel.errored {|msg| puts msg }

  inputs_channel.disconnected { puts 'Inputs disconnected!' }
end