#!/usr/bin/env ruby

require 'optparse'
require 'eventmachine'
require_relative '../lib/cable_manager'
require_relative '../lib/gpio_util'

DEFAULTS = {
  action_cable_host: 'localhost',
  action_cable_port: '3000'
}
parsed_options = DEFAULTS.dup
OptionParser.new do |opts|
  opts.on('-h', '--actioncable-host=host', 'ActionCable Host') do |v|
    parsed_options[:action_cable_host] = v
  end
  opts.on('-p', '--actioncable-port=port', 'ActionCable Port') do |v|
    parsed_options[:action_cable_port] = v
  end
end.parse!

uri = "ws://#{parsed_options[:action_cable_host]}:#{parsed_options[:action_cable_port]}/cable"

EventMachine.run do
  output_manager = CableManager.new('GpioOutputsChannel', uri: uri) do |msg|
    gpio_output = msg[:message][:gpio_output].deep_symbolize_keys
    GpioUtil.new(pin: gpio_output[:pin]).write value: gpio_output[:value]
  end.connect!

  input_manager = CableManager.new('GpioInputsChannel', uri: uri) do |msg|
    gpio_input = msg[:message][:gpio_input].deep_symbolize_keys
    util = GpioUtil.new(pin: gpio_input[:pin])
    case gpio_input[:mode]
      when 'read'
        puts "#{gpio_input[:pin]} reads #{util.read}!"
      when 'wait_for_up'
        util.wait_for(1) do
          puts "#{gpio_input[:pin]} went up!"
          input_manager.perform('create', pin: 23, mode: 'wait_for_down')
          output_manager.perform('create', pin: 17, value: 1)
        end
      when 'wait_for_down'
        util.wait_for(0) do
          puts "#{gpio_input[:pin]} went down!"
          output_manager.perform('create', pin: 17, value: 0)
        end
    end
  end.connect!
end